// npx buf generate proto

// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file busa.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { Message, proto3 } from '@bufbuild/protobuf';

/**
 * @generated from message Pattern
 */
export class Pattern extends Message<Pattern> {
  /**
   * @generated from oneof Pattern.is
   */
  is:
    | {
        /**
         * @generated from field: Pattern.PatternEnum enum = 1;
         */
        value: Pattern_PatternEnum;
        case: 'enum';
      }
    | {
        /**
         * @generated from field: bool bool = 2;
         */
        value: boolean;
        case: 'bool';
      }
    | {
        /**
         * @generated from field: int32 var = 3;
         */
        value: number;
        case: 'var';
      }
    | {
        /**
         * @generated from field: int64 int = 4;
         */
        value: bigint;
        case: 'int';
      }
    | {
        /**
         * @generated from field: string string = 5;
         */
        value: string;
        case: 'string';
      }
    | {
        /**
         * @generated from field: Pattern.Structure structure = 6;
         */
        value: Pattern_Structure;
        case: 'structure';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Pattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Pattern';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'enum', kind: 'enum', T: proto3.getEnumType(Pattern_PatternEnum), oneof: 'is' },
    { no: 2, name: 'bool', kind: 'scalar', T: 8 /* ScalarType.BOOL */, oneof: 'is' },
    { no: 3, name: 'var', kind: 'scalar', T: 5 /* ScalarType.INT32 */, oneof: 'is' },
    { no: 4, name: 'int', kind: 'scalar', T: 3 /* ScalarType.INT64 */, oneof: 'is' },
    { no: 5, name: 'string', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'is' },
    { no: 6, name: 'structure', kind: 'message', T: Pattern_Structure, oneof: 'is' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pattern {
    return new Pattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pattern {
    return new Pattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pattern {
    return new Pattern().fromJsonString(jsonString, options);
  }

  static equals(
    a: Pattern | PlainMessage<Pattern> | undefined,
    b: Pattern | PlainMessage<Pattern> | undefined,
  ): boolean {
    return proto3.util.equals(Pattern, a, b);
  }
}

/**
 * @generated from enum Pattern.PatternEnum
 */
export enum Pattern_PatternEnum {
  /**
   * @generated from enum value: Unit = 0;
   */
  Unit = 0,

  /**
   * @generated from enum value: Wildcard = 1;
   */
  Wildcard = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Pattern_PatternEnum)
proto3.util.setEnumType(Pattern_PatternEnum, 'Pattern.PatternEnum', [
  { no: 0, name: 'Unit' },
  { no: 1, name: 'Wildcard' },
]);

/**
 * @generated from message Pattern.Structure
 */
export class Pattern_Structure extends Message<Pattern_Structure> {
  /**
   * @generated from field: string name = 1;
   */
  name = '';

  /**
   * @generated from field: repeated Pattern args = 2;
   */
  args: Pattern[] = [];

  constructor(data?: PartialMessage<Pattern_Structure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Pattern.Structure';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'args', kind: 'message', T: Pattern, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pattern_Structure {
    return new Pattern_Structure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pattern_Structure {
    return new Pattern_Structure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pattern_Structure {
    return new Pattern_Structure().fromJsonString(jsonString, options);
  }

  static equals(
    a: Pattern_Structure | PlainMessage<Pattern_Structure> | undefined,
    b: Pattern_Structure | PlainMessage<Pattern_Structure> | undefined,
  ): boolean {
    return proto3.util.equals(Pattern_Structure, a, b);
  }
}

/**
 * @generated from message Rule
 */
export class Rule extends Message<Rule> {
  /**
   * @generated from oneof Rule.is
   */
  is:
    | {
        /**
         * @generated from field: Rule.Index index = 1;
         */
        value: Rule_Index;
        case: 'index';
      }
    | {
        /**
         * @generated from field: Rule.Join join = 2;
         */
        value: Rule_Join;
        case: 'join';
      }
    | {
        /**
         * @generated from field: Rule.Function function = 3;
         */
        value: Rule_Function;
        case: 'function';
      }
    | {
        /**
         * @generated from field: Rule.ChoiceConclusion choice_conclusion = 4;
         */
        value: Rule_ChoiceConclusion;
        case: 'choiceConclusion';
      }
    | {
        /**
         * @generated from field: Rule.DatalogConclusion datalog_conclusion = 5;
         */
        value: Rule_DatalogConclusion;
        case: 'datalogConclusion';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'index', kind: 'message', T: Rule_Index, oneof: 'is' },
    { no: 2, name: 'join', kind: 'message', T: Rule_Join, oneof: 'is' },
    { no: 3, name: 'function', kind: 'message', T: Rule_Function, oneof: 'is' },
    { no: 4, name: 'choice_conclusion', kind: 'message', T: Rule_ChoiceConclusion, oneof: 'is' },
    { no: 5, name: 'datalog_conclusion', kind: 'message', T: Rule_DatalogConclusion, oneof: 'is' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule | PlainMessage<Rule> | undefined,
    b: Rule | PlainMessage<Rule> | undefined,
  ): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 *
 * conclusion X0 ... XN :- premise <Args> is <Values>.
 *
 * - Premise uses arbitrary patterns with vars X0...XN
 * - Every variable is bound in the premise
 * - Conclusion has arguments in order
 * - Conclusion is a fact (with all args, no values)
 *
 * @generated from message Rule.Index
 */
export class Rule_Index extends Message<Rule_Index> {
  /**
   * @generated from field: string conclusion = 1;
   */
  conclusion = '';

  /**
   * @generated from field: int32 num_conclusion_args = 2;
   */
  numConclusionArgs = 0;

  /**
   * @generated from field: string premise = 3;
   */
  premise = '';

  /**
   * @generated from field: repeated Pattern args = 4;
   */
  args: Pattern[] = [];

  /**
   * @generated from field: repeated Pattern values = 5;
   */
  values: Pattern[] = [];

  constructor(data?: PartialMessage<Rule_Index>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.Index';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conclusion', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'num_conclusion_args', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: 'premise', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'args', kind: 'message', T: Pattern, repeated: true },
    { no: 5, name: 'values', kind: 'message', T: Pattern, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule_Index {
    return new Rule_Index().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule_Index {
    return new Rule_Index().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule_Index {
    return new Rule_Index().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_Index | PlainMessage<Rule_Index> | undefined,
    b: Rule_Index | PlainMessage<Rule_Index> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_Index, a, b);
  }
}

/**
 *
 * conclusion <Args> is <Values> :- prefix X0 ... XN
 *
 * - Premise has arguments X0 ... XN in order
 * - Conclusion has arbitrary patterns with vars X0...XN
 * - Conclusion is a fact
 *
 * @generated from message Rule.DatalogConclusion
 */
export class Rule_DatalogConclusion extends Message<Rule_DatalogConclusion> {
  /**
   * @generated from field: string conclusion = 1;
   */
  conclusion = '';

  /**
   * @generated from field: repeated Pattern args = 2;
   */
  args: Pattern[] = [];

  /**
   * @generated from field: repeated Pattern values = 3;
   */
  values: Pattern[] = [];

  /**
   * @generated from field: string prefix = 4;
   */
  prefix = '';

  constructor(data?: PartialMessage<Rule_DatalogConclusion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.DatalogConclusion';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conclusion', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'args', kind: 'message', T: Pattern, repeated: true },
    { no: 3, name: 'values', kind: 'message', T: Pattern, repeated: true },
    { no: 4, name: 'prefix', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rule_DatalogConclusion {
    return new Rule_DatalogConclusion().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Rule_DatalogConclusion {
    return new Rule_DatalogConclusion().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rule_DatalogConclusion {
    return new Rule_DatalogConclusion().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_DatalogConclusion | PlainMessage<Rule_DatalogConclusion> | undefined,
    b: Rule_DatalogConclusion | PlainMessage<Rule_DatalogConclusion> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_DatalogConclusion, a, b);
  }
}

/**
 *
 * conclusion <Args> is { <Values> } :- prefix X0 ... XN (exhaustive)
 * conclusion <Args> is { <Values>? } :- prefix X0 ... XN (non-exhaustive)
 *
 * - Premise has arguments X0 ... XN in order
 * - Conclusion has arbitrary patterns with vars X0...XN
 * - Conclusion is a fact with one value
 *
 * @generated from message Rule.ChoiceConclusion
 */
export class Rule_ChoiceConclusion extends Message<Rule_ChoiceConclusion> {
  /**
   * @generated from field: string conclusion = 1;
   */
  conclusion = '';

  /**
   * @generated from field: repeated Pattern args = 2;
   */
  args: Pattern[] = [];

  /**
   * @generated from field: repeated Pattern choices = 3;
   */
  choices: Pattern[] = [];

  /**
   * @generated from field: bool exhaustive = 4;
   */
  exhaustive = false;

  /**
   * @generated from field: string prefix = 5;
   */
  prefix = '';

  constructor(data?: PartialMessage<Rule_ChoiceConclusion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.ChoiceConclusion';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conclusion', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'args', kind: 'message', T: Pattern, repeated: true },
    { no: 3, name: 'choices', kind: 'message', T: Pattern, repeated: true },
    { no: 4, name: 'exhaustive', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: 'prefix', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rule_ChoiceConclusion {
    return new Rule_ChoiceConclusion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule_ChoiceConclusion {
    return new Rule_ChoiceConclusion().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rule_ChoiceConclusion {
    return new Rule_ChoiceConclusion().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_ChoiceConclusion | PlainMessage<Rule_ChoiceConclusion> | undefined,
    b: Rule_ChoiceConclusion | PlainMessage<Rule_ChoiceConclusion> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_ChoiceConclusion, a, b);
  }
}

/**
 *
 * conclusion Y3 X1 Z4 :- prefix X0 X1 Y2 Y3, fact X0 X1 Z2 is Z3 Z4.
 *
 * - Prefix and fact premise share first N arguments X0...XN
 * - prefix can have additional arguments ...YM, M >= N
 * - fact can have additional arguments in args and values ...ZP, P >= N
 * - conclusion is another prefix and has no repeat variables
 *
 * @generated from message Rule.Join
 */
export class Rule_Join extends Message<Rule_Join> {
  /**
   * @generated from field: string conclusion = 1;
   */
  conclusion = '';

  /**
   * @generated from field: repeated Rule.Join.JoinPattern args = 2;
   */
  args: Rule_Join_JoinPattern[] = [];

  /**
   * @generated from field: string prefix = 3;
   */
  prefix = '';

  /**
   * @generated from field: string fact = 4;
   */
  fact = '';

  /**
   * @generated from field: int32 num_shared = 5;
   */
  numShared = 0;

  constructor(data?: PartialMessage<Rule_Join>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.Join';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conclusion', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'args', kind: 'message', T: Rule_Join_JoinPattern, repeated: true },
    { no: 3, name: 'prefix', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'fact', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 5, name: 'num_shared', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule_Join {
    return new Rule_Join().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule_Join {
    return new Rule_Join().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule_Join {
    return new Rule_Join().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_Join | PlainMessage<Rule_Join> | undefined,
    b: Rule_Join | PlainMessage<Rule_Join> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_Join, a, b);
  }
}

/**
 * @generated from message Rule.Join.JoinPattern
 */
export class Rule_Join_JoinPattern extends Message<Rule_Join_JoinPattern> {
  /**
   * @generated from field: Rule.Join.JoinPattern.JoinLocation loc = 1;
   */
  loc = Rule_Join_JoinPattern_JoinLocation.Shared;

  /**
   * @generated from field: int32 var = 2;
   */
  var = 0;

  constructor(data?: PartialMessage<Rule_Join_JoinPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.Join.JoinPattern';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'loc', kind: 'enum', T: proto3.getEnumType(Rule_Join_JoinPattern_JoinLocation) },
    { no: 2, name: 'var', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rule_Join_JoinPattern {
    return new Rule_Join_JoinPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule_Join_JoinPattern {
    return new Rule_Join_JoinPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rule_Join_JoinPattern {
    return new Rule_Join_JoinPattern().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_Join_JoinPattern | PlainMessage<Rule_Join_JoinPattern> | undefined,
    b: Rule_Join_JoinPattern | PlainMessage<Rule_Join_JoinPattern> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_Join_JoinPattern, a, b);
  }
}

/**
 * @generated from enum Rule.Join.JoinPattern.JoinLocation
 */
export enum Rule_Join_JoinPattern_JoinLocation {
  /**
   * @generated from enum value: Shared = 0;
   */
  Shared = 0,

  /**
   * @generated from enum value: Prefix = 1;
   */
  Prefix = 1,

  /**
   * @generated from enum value: FactArg = 2;
   */
  FactArg = 2,

  /**
   * @generated from enum value: FactValue = 3;
   */
  FactValue = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Rule_Join_JoinPattern_JoinLocation)
proto3.util.setEnumType(Rule_Join_JoinPattern_JoinLocation, 'Rule.Join.JoinPattern.JoinLocation', [
  { no: 0, name: 'Shared' },
  { no: 1, name: 'Prefix' },
  { no: 2, name: 'FactArg' },
  { no: 3, name: 'FactValue' },
]);

/**
 *
 * conclusion X2 X4 X3 :- prefix X0 X1 X2 X3, <built-in-premise>
 *
 * - There are various extra constraints on each built-in premises,
 * but they can be forced to bind additional variables in some cases,
 * which can then be used in the conclusion (again, in some cases).
 * - conclusion is another prefix and has no repeat variables
 *
 * @generated from message Rule.Function
 */
export class Rule_Function extends Message<Rule_Function> {
  /**
   * @generated from field: string conclusion = 1;
   */
  conclusion = '';

  /**
   * @generated from field: repeated int32 args = 2;
   */
  args: number[] = [];

  /**
   * @generated from field: string prefix = 3;
   */
  prefix = '';

  /**
   * @generated from oneof Rule.Function.type
   */
  type:
    | {
        /**
         * @generated from field: Rule.Function.Builtin builtin = 4;
         */
        value: Rule_Function_Builtin;
        case: 'builtin';
      }
    | {
        /**
         * @generated from field: string other = 5;
         */
        value: string;
        case: 'other';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: repeated Pattern function_args = 6;
   */
  functionArgs: Pattern[] = [];

  /**
   * @generated from field: int32 num_vars = 7;
   */
  numVars = 0;

  constructor(data?: PartialMessage<Rule_Function>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Rule.Function';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conclusion', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'args', kind: 'scalar', T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 3, name: 'prefix', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    {
      no: 4,
      name: 'builtin',
      kind: 'enum',
      T: proto3.getEnumType(Rule_Function_Builtin),
      oneof: 'type',
    },
    { no: 5, name: 'other', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'type' },
    { no: 6, name: 'function_args', kind: 'message', T: Pattern, repeated: true },
    { no: 7, name: 'num_vars', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule_Function {
    return new Rule_Function().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule_Function {
    return new Rule_Function().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule_Function {
    return new Rule_Function().fromJsonString(jsonString, options);
  }

  static equals(
    a: Rule_Function | PlainMessage<Rule_Function> | undefined,
    b: Rule_Function | PlainMessage<Rule_Function> | undefined,
  ): boolean {
    return proto3.util.equals(Rule_Function, a, b);
  }
}

/**
 * @generated from enum Rule.Function.Builtin
 */
export enum Rule_Function_Builtin {
  /**
   * @generated from enum value: BOOLEAN_TRUE = 0;
   */
  BOOLEAN_TRUE = 0,

  /**
   * @generated from enum value: BOOLEAN_FALSE = 1;
   */
  BOOLEAN_FALSE = 1,

  /**
   * @generated from enum value: NAT_ZERO = 2;
   */
  NAT_ZERO = 2,

  /**
   * @generated from enum value: NAT_SUCC = 3;
   */
  NAT_SUCC = 3,

  /**
   * @generated from enum value: INT_PLUS = 4;
   */
  INT_PLUS = 4,

  /**
   * @generated from enum value: INT_MINUS = 5;
   */
  INT_MINUS = 5,

  /**
   * @generated from enum value: INT_TIMES = 6;
   */
  INT_TIMES = 6,

  /**
   * @generated from enum value: STRING_CONCAT = 7;
   */
  STRING_CONCAT = 7,

  /**
   * @generated from enum value: EQUAL = 8;
   */
  EQUAL = 8,

  /**
   * @generated from enum value: GT = 9;
   */
  GT = 9,

  /**
   * @generated from enum value: GEQ = 10;
   */
  GEQ = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(Rule_Function_Builtin)
proto3.util.setEnumType(Rule_Function_Builtin, 'Rule.Function.Builtin', [
  { no: 0, name: 'BOOLEAN_TRUE' },
  { no: 1, name: 'BOOLEAN_FALSE' },
  { no: 2, name: 'NAT_ZERO' },
  { no: 3, name: 'NAT_SUCC' },
  { no: 4, name: 'INT_PLUS' },
  { no: 5, name: 'INT_MINUS' },
  { no: 6, name: 'INT_TIMES' },
  { no: 7, name: 'STRING_CONCAT' },
  { no: 8, name: 'EQUAL' },
  { no: 9, name: 'GT' },
  { no: 10, name: 'GEQ' },
]);

/**
 * @generated from message Program
 */
export class Program extends Message<Program> {
  /**
   * @generated from field: repeated Rule rules = 1;
   */
  rules: Rule[] = [];

  /**
   * @generated from field: repeated string seeds = 2;
   */
  seeds: string[] = [];

  /**
   * @generated from field: repeated string forbids = 3;
   */
  forbids: string[] = [];

  /**
   * @generated from field: repeated string demands = 4;
   */
  demands: string[] = [];

  constructor(data?: PartialMessage<Program>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'Program';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'rules', kind: 'message', T: Rule, repeated: true },
    { no: 2, name: 'seeds', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: 'forbids', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: 'demands', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Program {
    return new Program().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Program {
    return new Program().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Program {
    return new Program().fromJsonString(jsonString, options);
  }

  static equals(
    a: Program | PlainMessage<Program> | undefined,
    b: Program | PlainMessage<Program> | undefined,
  ): boolean {
    return proto3.util.equals(Program, a, b);
  }
}
